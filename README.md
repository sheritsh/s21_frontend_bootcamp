#  Day 01 - Frontend boot camp


## Contents

1. [Chapter I](#chapter-i) \
   1.1. [Основные понятия ](#основные-понятия) \
   1.2 [Наследование классов](#наследование-классов) \
   1.3 [Методы и свойства](#методы-и-свойства)
2. [Chapter II](#chapter-ii) \
   2.1. [Асинхронность и JS](#асинхронность-и-js) \
   2.2 [Event loop](#event-loop) \
   2.3 [Callback-hell](#callback-hell) \
   2.4 [Promises](#promises) \
   2.5 [Async await](#async-await) \
   2.6 [File system](#file-system) 


## Chapter I

До недавнего времени промышленные разработчики использовали функции конструктора для имитации объектно-ориентированного шаблона в JavaScript. Языковая спецификация ECMAScript 2015 (часто называемая ES6) ввела в язык JavaScript понятие классов. Классы в JavaScript не добавляют дополнительные функции, и представляют собой способ упростить синтаксис при использовании прототипов и наследования и сделать его более элегантным. Поскольку в других языках программирования также используются классы, синтаксис классов в JavaScript упрощает работу для разработчиков, владеющих другими языками. 

### Основные понятия 

Класс JavaScript — это вид функции. Для декларирования классов используется ключевое слово class. Мы используем синтаксис выражения функции для инициализации функции и синтаксис выражения класса для инициализации класса.

JavaScript — это язык на базе прототипов, и каждый объект JavaScript имеет скрытое внутреннее свойство [[Prototype]], которое можно использовать для расширения свойств и методов объекта.

[Вот так выглядит пример объявления класса](./materials/Classes.md)

### Наследование классов 

Мы можем использовать наследование в классах с помощью ключевого слова **extend**. Для того, чтобы выполнить конструктор родительского класса мы используем метод super и передаем в него аргументы. Super используется для того, чтобы обратиться к родительскому классу. При этом в классе, который наследуется доступны все методы родителя.

### Методы и свойства

**Статические методы и свойства** 

Ключевое слово static, определяет статический метод или свойства для класса. Статические методы и свойства вызываются без инстанцирования их класса, и не могут быть вызваны у экземпляров (instance) класса. Статические методы, часто используются для создания служебных функций для приложения, в то время как статические свойства полезны для кеширования в рамках класса, фиксированной конфигурации или любых других целей, не связанных с реплицированием данных между экземплярами.

**Публичные и приватные поля** 

С помощью специального символа # мы можем объявить приватные поля объекта. Приватные поля могут быть изменены или прочитаны только в рамках класса и не могут быть вызваны извне.

Геттеры и сеттеры — это аксессоры или вычисляемые свойства. Это методы, имитирующие поля, но позволяющие читать и записывать данные.
Геттеры используются для получения данных, сеттеры — для их изменения.

**Задание 1.**  
Вам нужно описать класс Employee \
![image](https://user-images.githubusercontent.com/48245816/170902240-ab540276-e2b6-450f-ac32-d11ced7580ea.png)

[Заготовки для задания](./src/chapter_1/classes.js).
<br>

**Задание 2.**  
В продолжение прошлого задания вам нужно нужно создать [5 новых классов](./src/chapter_1/Hard_classes.md)

[Заготовки для задания](./src/chapter_1/hard_classes.js).
<br>
## Chapter II

### Асинхронность и JS

Большая часть функциональности, которую мы рассматривали в предыдущих уроках, является синхронной — вы запускаете какой-то код и он выполняется по порядку написания.
С простыми задачами с этим не возникает проблем, но теперь представьте, что вы запускаете задачу, которая занимает 30 секунд... Да. Во время этой задачи мы ждем 30 секунд, прежде чем что-либо еще может произойти. Здесь нам на помощь приходит асинхронность.

Что такое вообще — асинхронность? В отличие от синхронности, асинхронность это модель поведения. Предположим, что у нас есть две строчки кода, первая за второй. Первая строка это инструкция, для которой нужно время. итак, первая строка начинает запуск этой инструкции в фоновом режиме, позволяя второй строке запуститься без ожидания завершения первой строки.
Функция setTimeout() это простейший способ продемонстрировать основы асинхронного поведения.

### Event loop

Идея event loop очень проста. Есть бесконечный цикл, в котором движок JavaScript ожидает задачи, исполняет их и снова ожидает появления новых.
Общий алгоритм движка:
Пока есть задачи:
1. Выполнить их, начиная с самой старой.
2. Бездействовать до появления новой задачи, а затем перейти к пункту 1.

[Схема работы event loop](./materials/Event_loop.md).
И микрозадачи, и макрозадачи являются асинхронными задачами, но они будут входить в две разные асинхронные очереди, и приоритет очереди микрозадач выше приоритета макрозадачи.

### Callback-hell

Callback Hell - это паттерн для управления конкурирующими (асинхронными) запросами, который обеспечивает последовательность их выполнения.
Асинхронный JavaScript или JavaScript, в котором используются обратные вызовы — это то, в чём трудно интуитивно разобраться. 
В основном код выглядит вот так:

[Пример callbac-hella](./materials/CallBackHell.md)
### Promises

Объект Promise используется для отложенных и асинхронных вычислений.
Promise (промис) представляет собой обертку неизвестного на момент создания промиса значения. С помощью той обертки мы можем обработать результат асинхронной операции так, как если бы она была синхронной: вместо конечного результата асинхронного метода возвращается своего рода обещание (дословный перевод слова "promise") получить результат в некоторый момент в будущем.

Promise может находиться в трёх состояниях: \
`-` Ожидание (pending): начальное состояние, не исполнен и не отклонён. \
`-` Исполнено (fulfilled): операция завершена успешно. \
`-` Отклонено (rejected): операция завершена с ошибкой. 

У объекта Promise есть несколько полезных методов, которые позволяют работать с несколькими промисами одновременно или вычислять какой из данных промисов разрешится быстрее.

### Async await

Для работы с промисами существует специальный сиинтаксис «async/await».

Ключевое слово **async** перед функцией гарантирует, что эта функция в любом случае вернёт промис. Но это ещё не всё. Есть другое ключевое слово – **await** , которое можно использовать только внутри async-функций. 

Ключевое слово await заставит интерпретатор JavaScript ждать до тех пор, пока промис справа от await не выполнится. После чего оно вернёт его результат, и выполнение кода продолжится. [Пример](./materials/Async_await.md)

### File system

В Node.JS, для работы с файлами существует модуль «FS» и в нем есть множество функций для самых различных операций с файлами и директориями. [Вот документация](https://nodejs.org/api/fs.html). Если мы приглядимся внимательно, то увидим первую особенность этого модуля, почти все функции имеют два варианта. Первое просто имя, второе со словом Sync. Слово Sync означает синхронно.Если я например вызову **fs.readFile(file[, options], callback)**, то он сначала прочитает файл полностью, а потом вызовет callback. А **fs.readFileSync(file[, options])** затормозит выполнение процесса пока файл не будет прочитан. В заданиях необходимо использовать асинхронный вариант!

**Задание 3.**  

Вам нужно прочитать данные из файла file1.txt, после прочтения полученные данные надо записать в файл file2.txt Реализовать это надо 3 разными способами, для каждого способа своя функция: \
`-` readAndWriteCallbackHell() - в данной функции вы должны использовать только передачу коллбека в ассинхронную функцию. \
`-` readAndWritePromises() - в данной функции вы должны использовать промисы и then. \
`-` readAndWriteAsyncAwait() - в данной функции можно использовать async await.

Заготовки для задания вы можете найти по [ссылке](./src/chapter_2/fsSimple.js).
<br>

**Задание 4.**  

Когда пользователь загружает страницу - данные с сервера поступают на клиент асинхронно и неравномерно. 
Давай смоделируем такое поведение при помощи файловой системы твоего проекта. Тебе предстоит написать progressbar, применимый не к статически заданному времени, а к размеру "загружаемых" файлов. На основании полученых размеров файлов, реализуй свой progressbar. 
Твой прогрессбар будет заполняться до общего размера всех имеющихся файлов в [папке](./src/chapter_2/files/fsHard). Если у тебя есть файл, размером 5Кб при общем размере всех файлов - 10 Кб, то твоя полоса загрузки после обработки такого файла должна заполниться на 50% (100% * (5Кб / 10Кб)). 
Сделай полосу загрузки(progressbar) в **Консоли Терминала**. Не в браузере! Она должна увеличиваться с каждым новым загруженным файлом.

Заготовки для задания вы можете найти по [ссылке](./src/chapter_2/fsHard.js).

<br>
>Пожалуйста, оставьте обратную связь по проекту в [форме обратной связи.](https://forms.gle/Qbn2DW2VoY91JEVe9)
